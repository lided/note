import{_ as a,c as i,o as e,ag as t}from"./chunks/framework.DPDPlp3K.js";const _=JSON.parse('{"title":"创建者模式","description":"","frontmatter":{},"headers":[],"relativePath":"java/design-mode/大纲.md","filePath":"java/design-mode/大纲.md"}'),r={name:"java/design-mode/大纲.md"};function o(s,l,n,h,d,c){return e(),i("div",null,l[0]||(l[0]=[t('<h1 id="创建者模式" tabindex="-1">创建者模式 <a class="header-anchor" href="#创建者模式" aria-label="Permalink to &quot;创建者模式&quot;">​</a></h1><p>提供了一种在创建对象的同时隐藏创建逻辑的方式，而不是使用 new 运算符直接实例化对象。这使得程序在判断针对某个给定实例需要创建哪些对象时更加灵活。</p><ul><li><a href="./创建型模式/抽象工厂模式.html">抽象工厂模式</a></li><li>工厂方法模式</li><li><a href="./创建型模式/单例模式.html">单例模式</a></li><li>建造者模式</li><li>原型模式</li></ul><hr><h1 id="结构性模式" tabindex="-1">结构性模式 <a class="header-anchor" href="#结构性模式" aria-label="Permalink to &quot;结构性模式&quot;">​</a></h1><p>这些模式关注对象之间的组合和关系，旨在解决如何构建灵活且可复用的类和对象结构。</p><ul><li>适配器模式</li><li>装饰者模式</li><li>代理模式</li><li>外观模式</li><li>桥接模式</li><li>组合模式</li><li>享元模式</li></ul><hr><h1 id="行为型模式" tabindex="-1">行为型模式 <a class="header-anchor" href="#行为型模式" aria-label="Permalink to &quot;行为型模式&quot;">​</a></h1><p>这些模式关注对象之间的通信和交互，旨在解决对象之间的责任分配和算法的封装。</p><ul><li><a href="./行为型模式/strategy策略模式.html">strategy策略模式</a></li><li>模板方法模式</li><li>观察者模式</li><li>迭代子模式</li><li><a href="./行为型模式/责任链模式.html">责任链模式</a></li><li>命令模式</li><li>备忘录模式</li><li>状态模式</li><li>访问者模式</li><li>中介模式</li><li>解释器模式</li></ul><h1 id="问题" tabindex="-1">问题 <a class="header-anchor" href="#问题" aria-label="Permalink to &quot;问题&quot;">​</a></h1><h6 id="工厂方法-vs-抽象工厂" tabindex="-1">工厂方法 vs 抽象工厂 <a class="header-anchor" href="#工厂方法-vs-抽象工厂" aria-label="Permalink to &quot;工厂方法 vs 抽象工厂&quot;">​</a></h6><ul><li><strong>工厂方法</strong>:当系统需要 ​灵活支持多种独立产品的变体​（如不同数据库驱动：MySQL/Oracle连接器）</li><li><strong>抽象工厂</strong>:当需要 ​保证多个相关产品的一致性​（如成套的UI组件、跨平台文件系统接口）</li></ul>',14)]))}const m=a(r,[["render",o]]);export{_ as __pageData,m as default};
