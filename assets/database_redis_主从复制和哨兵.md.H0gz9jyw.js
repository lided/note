import{_ as e,c as s,o as t,ag as l}from"./chunks/framework.DPDPlp3K.js";const u=JSON.parse('{"title":"主从","description":"","frontmatter":{},"headers":[],"relativePath":"database/redis/主从复制和哨兵.md","filePath":"database/redis/主从复制和哨兵.md"}'),i={name:"database/redis/主从复制和哨兵.md"};function n(p,a,r,o,d,c){return t(),s("div",null,a[0]||(a[0]=[l(`<h1 id="主从" tabindex="-1">主从 <a class="header-anchor" href="#主从" aria-label="Permalink to &quot;主从&quot;">​</a></h1><h2 id="配置" tabindex="-1">配置 <a class="header-anchor" href="#配置" aria-label="Permalink to &quot;配置&quot;">​</a></h2><p>主机无需配置,只需在从机上配置</p><p>设置要访问master密码</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>masterauth &lt;master_pwd&gt;</span></span></code></pre></div><p>设置master主机ip地址</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>replicaof &lt;master_ip&gt; &lt;port&gt;</span></span></code></pre></div><h2 id="开始" tabindex="-1">开始 <a class="header-anchor" href="#开始" aria-label="Permalink to &quot;开始&quot;">​</a></h2><p>按照master,slave顺序一次启动redis服务</p><p>使用info命令查看主从信息</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>info replication</span></span></code></pre></div><ul><li>主机die后,从机会原地等待主机上线</li><li>slave在启动时会将master所有数据获取</li></ul><h2 id="动态配置" tabindex="-1">动态配置 <a class="header-anchor" href="#动态配置" aria-label="Permalink to &quot;动态配置&quot;">​</a></h2><p>当没有在配置文件中配置主机IP时,可以在客户端命令行使用以下命令将当前redis配置为slave</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>slaveof &lt;master_ip:port&gt;</span></span></code></pre></div><p>取消上述主从配置</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>slaveof no one</span></span></code></pre></div><h2 id="流程" tabindex="-1">流程 <a class="header-anchor" href="#流程" aria-label="Permalink to &quot;流程&quot;">​</a></h2><ol><li>slave启动连接到master后,会发送sync命令,将master所有数据全部复制,并覆盖slave自身原有的数据</li><li>master接收到sync命令后,会开始在后台保存rdb,同时收集所有接收到的修改数据集命令,rdb持久化完成后,开始向slave发送rdb文件和命令.</li><li>master会默认每10秒钟发送心跳检测</li><li>持续连接过程中,master会将修改命令自动传给slave</li><li>master和slave都会保存offset信息,保证slave异常下线重新上线后master会从指定位置加载数据</li></ol><h2 id="缺点" tabindex="-1">缺点 <a class="header-anchor" href="#缺点" aria-label="Permalink to &quot;缺点&quot;">​</a></h2><ul><li>slave只能读不能写,当master异常die后整个主从都会无法正常使用(读)</li><li>随着服务器越来越多,从master到slave传输延迟越来越大</li></ul><h1 id="sentinel监控" tabindex="-1">sentinel监控 <a class="header-anchor" href="#sentinel监控" aria-label="Permalink to &quot;sentinel监控&quot;">​</a></h1><h2 id="配置-1" tabindex="-1">配置 <a class="header-anchor" href="#配置-1" aria-label="Permalink to &quot;配置&quot;">​</a></h2><p>将redis安装目录中的sentinel.conf复制一份到自己配置目录.</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span># 配置需要监听的redis</span></span>
<span class="line"><span># quorum表示需要获得确认的sentinel服务器数量</span></span>
<span class="line"><span>sentinel monitor &lt;master-name&gt; &lt;ip&gt; &lt;redis-port&gt; &lt;quorum&gt;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>#配置master密码</span></span>
<span class="line"><span>sentinel auth-pass &lt;master -name&gt; &lt;master-pwd&gt;</span></span></code></pre></div><p>由于master也有可能变为从机,也需要从机配置</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>masterauth lide</span></span></code></pre></div><h2 id="启动" tabindex="-1">启动 <a class="header-anchor" href="#启动" aria-label="Permalink to &quot;启动&quot;">​</a></h2><p>先启动三个主从redis</p><p>使用redis-sentinel命令启动哨兵</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>redis-sentinel /path/to/sentinel.conf</span></span>
<span class="line"><span>#或者</span></span>
<span class="line"><span>redis-server /path/to/sentinel.conf --sentinel.conf</span></span></code></pre></div><p>在sentinel.log文件中查看信息.如成功会在sentinel.conf文件中写入主从信息</p><p>在master中shutdown模拟异常die,过几秒在slave中查看主从信息会发现有一台slave变成master</p><p>如果在slave中报错,是因为master断开导致,sentinel正在选择新的master,稍等即可</p><p>sentinel会在运行过程中动态修改主从redis的redis.conf文件,以保证master在不同服务器切换时其他slave都能正确连接</p><p>也可以通过查看sentinel.log文件查看</p><p>当原来的master重新上线后会成为slave</p><h2 id="流程-1" tabindex="-1">流程 <a class="header-anchor" href="#流程-1" aria-label="Permalink to &quot;流程&quot;">​</a></h2><ol><li>sentinel会定期(默认30秒)检查redis服务器是否正常运行</li><li>当master服务器故障后,sentinel会通过raft算法投票选出一个主哨兵leader。</li><li>这个leader会根据所有slave的下面规则按顺序比较选出一个新的master <ol><li>replica-priority配置(越小优先级越高)，</li><li>offset(slave数据偏移量)，</li><li>id</li></ol></li><li>leader对新的master执行 slaveof no one 命令使其成为master，并对其他slave发送切换master命令</li><li>如果旧的master重新上线，会让其成为新的master的slave</li></ol><h2 id="使用建议" tabindex="-1">使用建议 <a class="header-anchor" href="#使用建议" aria-label="Permalink to &quot;使用建议&quot;">​</a></h2><ol><li>sentinel使用多个，保证高可用</li><li>sentinel数量尽量为奇数。保证投票不冲突</li><li>各个sentinel服务器配置尽量相同</li><li>sentinel只做监控作用并不能保证数据零丢失</li></ol>`,41)]))}const m=e(i,[["render",n]]);export{u as __pageData,m as default};
