import{_ as e,c as a,o,ag as r}from"./chunks/framework.DPDPlp3K.js";const d=JSON.parse('{"title":"介绍","description":"","frontmatter":{},"headers":[],"relativePath":"java/juc/jmm.md","filePath":"java/juc/jmm.md"}'),l={name:"java/juc/jmm.md"};function i(n,t,s,p,c,_){return o(),a("div",null,t[0]||(t[0]=[r('<h1 id="介绍" tabindex="-1">介绍 <a class="header-anchor" href="#介绍" aria-label="Permalink to &quot;介绍&quot;">​</a></h1><ol><li>所有线程共享变量都存储在物理主内存中</li><li>每个线程都有自己独立的工作内存,保存使用到的共享内存的副本</li><li>线程对共享变量的操作必须现在自己工作区域中后写回主内存,不能直接操作主内存</li><li>线程无法访问其他线程独立内存,只能通过主内存交互</li></ol><h1 id="happens-before-先行发生原则" tabindex="-1">happens-before(先行发生原则) <a class="header-anchor" href="#happens-before-先行发生原则" aria-label="Permalink to &quot;happens-before(先行发生原则)&quot;">​</a></h1><p>如果一个操作在另一个操作之前,那么第一个操作的执行结果将对第二个操作可见</p><p>有时候俩个操作的实际执行顺序对最终结果没有影响(俩个操作互不影响),那么不一定要按照原则来执行</p><ol><li><strong>次序规则</strong> 前面操作的结果可以被后面操作获取</li><li><strong>锁定规则</strong> unlock()先行发生于lock()</li><li><strong>volatile变量规则</strong> volatile变量写操作先行于读操作</li><li><strong>传递规则</strong> A先于B,B先于C,那么A先于C</li><li><strong>线程启动规则</strong> start()先于线程所有动作</li><li><strong>线程中断规则</strong> interrupt()中断方法先于isInterrupted()检测是否中断方法</li><li><strong>线程终止规则</strong> 线程所有操作先于终止检测</li><li><strong>对象终结规则</strong> 对象初始化先于finalize()</li></ol>',6)]))}const g=e(l,[["render",i]]);export{d as __pageData,g as default};
